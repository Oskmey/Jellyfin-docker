#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
EXAMPLE_FILE="${REPO_ROOT}/.env.example"
ENV_FILE="${REPO_ROOT}/.env"
NON_INTERACTIVE=0

usage() {
  cat <<USAGE
Usage: scripts/setup.sh [--non-interactive] [--env-file PATH]

Options:
  --non-interactive  Validate and use an existing env file without prompts.
  --env-file PATH    Path to env file (default: .env in repo root).
  -h, --help         Show this help.
USAGE
}

prompt_default() {
  local prompt="$1"
  local default="$2"
  local value
  read -r -p "${prompt} [${default}]: " value
  if [[ -z "${value}" ]]; then
    value="${default}"
  fi
  printf '%s' "${value}"
}

prompt_required() {
  local prompt="$1"
  local value=""
  while [[ -z "${value}" ]]; do
    read -r -p "${prompt}: " value
  done
  printf '%s' "${value}"
}

resolve_path() {
  local path_value="$1"
  if [[ "${path_value}" = /* ]]; then
    printf '%s' "${path_value}"
  else
    printf '%s' "${REPO_ROOT}/${path_value}"
  fi
}

validate_required_env() {
  local missing=0
  local required=(
    COMMON_PATH
    TZ
    PUID
    PGID
    WIREGUARD_ADDRESSES
    WIREGUARD_PRIVATE_KEY
    WIREGUARD_PUBLIC_KEY
    WIREGUARD_ENDPOINT
    WIREGUARD_ALLOWED_IPS
  )

  for key in "${required[@]}"; do
    if [[ -z "${!key:-}" ]]; then
      echo "ERROR: ${key} is missing from ${ENV_FILE}" >&2
      missing=1
    fi
  done

  if [[ "${missing}" -ne 0 ]]; then
    exit 1
  fi
}

write_env_file() {
  cat > "${ENV_FILE}" <<EOF_ENV
# Generated by scripts/setup.sh
COMMON_PATH=${COMMON_PATH}
TZ=${TZ}
PUID=${PUID}
PGID=${PGID}
NGINX_PORT=${NGINX_PORT}
DNS=${DNS}
SERVER_COUNTRIES=${SERVER_COUNTRIES}
WIREGUARD_ADDRESSES=${WIREGUARD_ADDRESSES}
WIREGUARD_PRIVATE_KEY=${WIREGUARD_PRIVATE_KEY}
WIREGUARD_PUBLIC_KEY=${WIREGUARD_PUBLIC_KEY}
WIREGUARD_ENDPOINT=${WIREGUARD_ENDPOINT}
WIREGUARD_ALLOWED_IPS=${WIREGUARD_ALLOWED_IPS}
EOF_ENV
}

create_directories() {
  local base_path
  base_path="$(resolve_path "${COMMON_PATH}")"

  local dirs=(
    "${base_path}/Qbittorrent/Config"
    "${base_path}/Downloads"
    "${base_path}/Sonarr/Config"
    "${base_path}/Sonarr/Backup"
    "${base_path}/Sonarr/tvshows"
    "${base_path}/Radarr/Config"
    "${base_path}/Radarr/Backup"
    "${base_path}/Radarr/movies"
    "${base_path}/Prowlarr/Config"
    "${base_path}/Prowlarr/Backup"
    "${base_path}/Jellyfin/Config"
    "${base_path}/Jellyfin/Cache"
    "${base_path}/Jellyseerr/Config"
    "${base_path}/Portainer/Data"
  )

  for dir in "${dirs[@]}"; do
    mkdir -p "${dir}"
  done

  local key_file="${base_path}/Portainer/Data/portainer.key"
  if [[ ! -f "${key_file}" ]]; then
    umask 177
    head -c 32 /dev/urandom | base64 > "${key_file}"
    chmod 600 "${key_file}"
  fi
}

run_preflight() {
  (
    cd "${REPO_ROOT}"
    docker compose --env-file "${ENV_FILE}" config > /dev/null
  )
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --non-interactive)
      NON_INTERACTIVE=1
      shift
      ;;
    --env-file)
      if [[ $# -lt 2 ]]; then
        echo "ERROR: --env-file requires a path." >&2
        exit 1
      fi
      ENV_FILE="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "ERROR: Unknown argument: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [[ "${ENV_FILE}" != /* ]]; then
  ENV_FILE="${REPO_ROOT}/${ENV_FILE}"
fi

if [[ ! -f "${EXAMPLE_FILE}" ]]; then
  echo "ERROR: Missing ${EXAMPLE_FILE}" >&2
  exit 1
fi

if [[ "${NON_INTERACTIVE}" -eq 1 ]]; then
  if [[ ! -f "${ENV_FILE}" ]]; then
    echo "ERROR: ${ENV_FILE} does not exist. Run interactive setup first." >&2
    exit 1
  fi
else
  local_tz="UTC"
  if [[ -f /etc/timezone ]]; then
    local_tz="$(< /etc/timezone)"
  fi

  use_existing="no"
  if [[ -f "${ENV_FILE}" ]]; then
    read -r -p "${ENV_FILE} already exists. Reuse it? [Y/n]: " reuse_reply
    if [[ -z "${reuse_reply}" || "${reuse_reply}" =~ ^[Yy]$ ]]; then
      use_existing="yes"
    fi
  fi

  if [[ "${use_existing}" != "yes" ]]; then
    COMMON_PATH="$(prompt_default "COMMON_PATH" "./data")"
    TZ="$(prompt_default "TZ" "${local_tz}")"
    PUID="$(prompt_default "PUID" "$(id -u)")"
    PGID="$(prompt_default "PGID" "$(id -g)")"
    NGINX_PORT="$(prompt_default "NGINX_PORT" "8090")"
    DNS="$(prompt_default "DNS" "1.1.1.1")"
    SERVER_COUNTRIES="$(prompt_default "SERVER_COUNTRIES" "Sweden")"
    WIREGUARD_ADDRESSES="$(prompt_required "WIREGUARD_ADDRESSES")"
    WIREGUARD_PRIVATE_KEY="$(prompt_required "WIREGUARD_PRIVATE_KEY")"
    WIREGUARD_PUBLIC_KEY="$(prompt_required "WIREGUARD_PUBLIC_KEY")"
    WIREGUARD_ENDPOINT="$(prompt_required "WIREGUARD_ENDPOINT")"
    WIREGUARD_ALLOWED_IPS="$(prompt_default "WIREGUARD_ALLOWED_IPS" "0.0.0.0/0,::/0")"

    write_env_file
    echo "Wrote ${ENV_FILE}"
  fi
fi

set -a
# shellcheck disable=SC1090
source "${ENV_FILE}"
set +a

validate_required_env
create_directories
run_preflight

echo "Setup completed successfully."
echo "Next step: docker compose --env-file ${ENV_FILE} up -d"
