#!/usr/bin/env bash
set -Eeuo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
EXAMPLE_FILE="${REPO_ROOT}/.env.example"
ENV_FILE="${REPO_ROOT}/.env"
NON_INTERACTIVE=0
FORCE=0
NO_COLOR=0
CURRENT_STEP="startup"
DIR_CREATED=0
DIR_REUSED=0
KEY_CREATED=0
KEY_REUSED=0
WARNINGS=0
FAILURES=0

if [[ -t 1 && "${NO_COLOR:-0}" != "1" ]]; then
  C_RESET='\033[0m'
  C_BOLD='\033[1m'
  C_DIM='\033[2m'
  C_RED='\033[31m'
  C_GREEN='\033[32m'
  C_YELLOW='\033[33m'
  C_BLUE='\033[34m'
  C_CYAN='\033[36m'
else
  C_RESET=''
  C_BOLD=''
  C_DIM=''
  C_RED=''
  C_GREEN=''
  C_YELLOW=''
  C_BLUE=''
  C_CYAN=''
fi

usage() {
  cat <<USAGE
Usage: scripts/setup.sh [options]

Options:
  --non-interactive   Validate and use an existing env file without prompts.
  --env-file PATH     Path to env file (default: .env in repo root).
  --force             Overwrite existing env values without reuse prompt.
  --no-color          Disable colored output.
  -h, --help          Show this help.
USAGE
}

print_header() {
  printf "%b\n" "${C_BOLD}${C_BLUE}============================================================${C_RESET}"
  printf "%b\n" "${C_BOLD}${C_BLUE}  Jellyfin Docker Setup${C_RESET}"
  printf "%b\n" "${C_DIM}  Repository: ${REPO_ROOT}${C_RESET}"
  printf "%b\n" "${C_BOLD}${C_BLUE}============================================================${C_RESET}"
  printf "\n"
}

log_step() {
  CURRENT_STEP="$*"
  printf "\n"
  printf "%b\n" "${C_BOLD}${C_CYAN}==> ${CURRENT_STEP}${C_RESET}"
}

log_info() {
  printf "%b\n" "${C_BLUE}[INFO]${C_RESET} $*"
}

log_ok() {
  printf "%b\n" "${C_GREEN}[ OK ]${C_RESET} $*"
}

log_skip() {
  printf "%b\n" "${C_DIM}[SKIP]${C_RESET} $*"
}

log_warn() {
  WARNINGS=$((WARNINGS + 1))
  printf "%b\n" "${C_YELLOW}[WARN]${C_RESET} $*"
}

log_err() {
  printf "%b\n" "${C_RED}[ERR ]${C_RESET} $*" >&2
}

die() {
  FAILURES=$((FAILURES + 1))
  log_err "$*"
  exit 1
}

on_error() {
  local exit_code="$1"
  local line_no="$2"
  local command="$3"
  local source_file="${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}"

  FAILURES=$((FAILURES + 1))
  log_err "Step failed: ${CURRENT_STEP}"
  log_err "Location: ${source_file}:${line_no}"
  log_err "Exit code: ${exit_code}"
  log_err "Command: ${command}"
}

trap 'on_error $? ${LINENO} "$BASH_COMMAND"' ERR

mask_value() {
  local value="$1"
  local len=${#value}
  if [[ "${len}" -le 8 ]]; then
    printf '********'
    return
  fi
  printf '%s****%s' "${value:0:4}" "${value: -4}"
}

resolve_path() {
  local value="$1"
  if [[ "${value}" = /* ]]; then
    printf '%s' "${value}"
  else
    printf '%s' "${REPO_ROOT}/${value}"
  fi
}

require_commands() {
  command -v docker >/dev/null 2>&1 || die "docker is not installed or not in PATH."
  docker compose version >/dev/null 2>&1 || die "docker compose plugin is not available."
}

prompt_default() {
  local prompt="$1"
  local default="$2"
  local value
  read -r -p "${prompt} [${default}]: " value
  if [[ -z "${value}" ]]; then
    value="${default}"
  fi
  printf '%s' "${value}"
}

prompt_required() {
  local prompt="$1"
  local default="$2"
  local value=""

  while [[ -z "${value}" ]]; do
    if [[ -n "${default}" ]]; then
      read -r -p "${prompt} [${default}]: " value
      if [[ -z "${value}" ]]; then
        value="${default}"
      fi
    else
      read -r -p "${prompt}: " value
    fi
  done

  printf '%s' "${value}"
}

validate_required_env() {
  local missing=0
  local required=(
    COMMON_PATH
    TZ
    PUID
    PGID
    WIREGUARD_ADDRESSES
    WIREGUARD_PRIVATE_KEY
    WIREGUARD_PUBLIC_KEY
    WIREGUARD_ENDPOINT
    WIREGUARD_ALLOWED_IPS
    UNPACKERR_SONARR_API_KEY
    UNPACKERR_RADARR_API_KEY
  )

  for key in "${required[@]}"; do
    if [[ -z "${!key:-}" ]]; then
      log_err "${key} is missing in ${ENV_FILE}"
      missing=1
    fi
  done

  if [[ "${missing}" -ne 0 ]]; then
    exit 1
  fi
}

load_env_file() {
  [[ -f "${ENV_FILE}" ]] || die "Missing env file: ${ENV_FILE}"

  set -a
  # shellcheck disable=SC1090
  source "${ENV_FILE}"
  set +a
}

write_env_file() {
  cat > "${ENV_FILE}" <<ENVEOF
# Generated by scripts/setup.sh
COMMON_PATH=${COMMON_PATH}
TZ=${TZ}
PUID=${PUID}
PGID=${PGID}
NGINX_PORT=${NGINX_PORT}
JELLYSEERR_PORT=${JELLYSEERR_PORT}
DNS=${DNS}
SERVER_COUNTRIES=${SERVER_COUNTRIES}
WIREGUARD_ADDRESSES=${WIREGUARD_ADDRESSES}
WIREGUARD_PRIVATE_KEY=${WIREGUARD_PRIVATE_KEY}
WIREGUARD_PUBLIC_KEY=${WIREGUARD_PUBLIC_KEY}
WIREGUARD_ENDPOINT=${WIREGUARD_ENDPOINT}
WIREGUARD_ALLOWED_IPS=${WIREGUARD_ALLOWED_IPS}
UNPACKERR_SONARR_API_KEY=${UNPACKERR_SONARR_API_KEY}
UNPACKERR_RADARR_API_KEY=${UNPACKERR_RADARR_API_KEY}
HOMEPAGE_ALLOWED_HOSTS=${HOMEPAGE_ALLOWED_HOSTS}
ENVEOF
  log_ok "Wrote ${ENV_FILE}"
}

print_summary() {
  printf "\n"
  printf "%b\n" "${C_BOLD}Configuration Summary${C_RESET}"
  printf "  %-24s %s\n" "COMMON_PATH" "${COMMON_PATH}"
  printf "  %-24s %s\n" "COMMON_PATH (absolute)" "$(resolve_path "${COMMON_PATH}")"
  printf "  %-24s %s\n" "TZ" "${TZ}"
  printf "  %-24s %s\n" "PUID/PGID" "${PUID}/${PGID}"
  printf "  %-24s %s\n" "NGINX_PORT" "${NGINX_PORT}"
  printf "  %-24s %s\n" "JELLYSEERR_PORT" "${JELLYSEERR_PORT}"
  printf "  %-24s %s\n" "DNS" "${DNS}"
  printf "  %-24s %s\n" "SERVER_COUNTRIES" "${SERVER_COUNTRIES}"
  printf "  %-24s %s\n" "HOMEPAGE_ALLOWED_HOSTS" "${HOMEPAGE_ALLOWED_HOSTS}"
  printf "  %-24s %s\n" "WIREGUARD_ADDRESSES" "$(mask_value "${WIREGUARD_ADDRESSES}")"
  printf "  %-24s %s\n" "WIREGUARD_PRIVATE_KEY" "$(mask_value "${WIREGUARD_PRIVATE_KEY}")"
  printf "  %-24s %s\n" "WIREGUARD_PUBLIC_KEY" "$(mask_value "${WIREGUARD_PUBLIC_KEY}")"
  printf "  %-24s %s\n" "WIREGUARD_ENDPOINT" "${WIREGUARD_ENDPOINT}"
  printf "  %-24s %s\n" "WIREGUARD_ALLOWED_IPS" "${WIREGUARD_ALLOWED_IPS}"
  printf "  %-24s %s\n" "UNPACKERR_SONARR_API_KEY" "$(mask_value "${UNPACKERR_SONARR_API_KEY}")"
  printf "  %-24s %s\n" "UNPACKERR_RADARR_API_KEY" "$(mask_value "${UNPACKERR_RADARR_API_KEY}")"
}

ensure_directory() {
  local dir="$1"

  if [[ -d "${dir}" ]]; then
    DIR_REUSED=$((DIR_REUSED + 1))
    log_skip "Reused existing folder: ${dir}"
    return
  fi

  if [[ -e "${dir}" ]]; then
    die "Path exists but is not a directory: ${dir}"
  fi

  mkdir -p "${dir}" || die "Failed to create folder: ${dir}"
  DIR_CREATED=$((DIR_CREATED + 1))
  log_ok "Created folder: ${dir}"
}

ensure_portainer_key() {
  local key_file="$1"

  if [[ -f "${key_file}" ]]; then
    KEY_REUSED=$((KEY_REUSED + 1))
    log_skip "Reused existing Portainer key: ${key_file}"
    return
  fi

  if [[ -e "${key_file}" ]]; then
    die "Portainer key path exists but is not a regular file: ${key_file}"
  fi

  (
    umask 177
    head -c 32 /dev/urandom | base64 > "${key_file}"
  ) || die "Failed to generate Portainer key: ${key_file}"

  chmod 600 "${key_file}" || die "Failed to apply permissions to Portainer key: ${key_file}"
  KEY_CREATED=$((KEY_CREATED + 1))
  log_ok "Created Portainer key: ${key_file}"
}

print_final_summary() {
  printf "\n"
  printf "%b\n" "${C_BOLD}Setup Summary${C_RESET}"
  printf "  %-24s %s\n" "Directories created" "${DIR_CREATED}"
  printf "  %-24s %s\n" "Directories reused" "${DIR_REUSED}"
  printf "  %-24s %s\n" "Portainer keys created" "${KEY_CREATED}"
  printf "  %-24s %s\n" "Portainer keys reused" "${KEY_REUSED}"
  printf "  %-24s %s\n" "Warnings" "${WARNINGS}"
  printf "  %-24s %s\n" "Failures" "${FAILURES}"
}

create_directories() {
  local base_path
  base_path="$(resolve_path "${COMMON_PATH}")"

  local dirs=(
    "${base_path}/Qbittorrent/Config"
    "${base_path}/Downloads"
    "${base_path}/Sonarr/Config"
    "${base_path}/Sonarr/Backup"
    "${base_path}/Sonarr/tvshows"
    "${base_path}/Radarr/Config"
    "${base_path}/Radarr/Backup"
    "${base_path}/Radarr/movies"
    "${base_path}/Prowlarr/Config"
    "${base_path}/Prowlarr/Backup"
    "${base_path}/Jellyfin/Config"
    "${base_path}/Jellyfin/Cache"
    "${base_path}/Jellyseerr/Config"
    "${base_path}/Bazarr/Config"
    "${base_path}/Unpackerr/Config"
    "${base_path}/Homepage/Config"
    "${base_path}/Portainer/Data"
  )

  log_info "COMMON_PATH resolved to: ${base_path}"
  ensure_directory "${base_path}"

  log_info "Ensuring media and config folders..."
  for dir in "${dirs[@]}"; do
    ensure_directory "${dir}"
  done
  log_ok "Folder checks complete (${#dirs[@]} targets)."

  local key_file="${base_path}/Portainer/Data/portainer.key"
  ensure_portainer_key "${key_file}"
}

run_preflight() {
  log_info "Running docker compose preflight validation..."
  (
    cd "${REPO_ROOT}"
    docker compose --env-file "${ENV_FILE}" config > /dev/null
  )
  log_ok "Compose preflight passed."
}

interactive_collect() {
  local default_tz="UTC"
  if [[ -f /etc/timezone ]]; then
    default_tz="$(< /etc/timezone)"
  fi

  local default_common_path="${COMMON_PATH:-./data}"
  local default_tz_value="${TZ:-${default_tz}}"
  local default_puid="${PUID:-$(id -u)}"
  local default_pgid="${PGID:-$(id -g)}"
  local default_nginx_port="${NGINX_PORT:-8090}"
  local default_jellyseerr_port="${JELLYSEERR_PORT:-5055}"
  local default_dns="${DNS:-1.1.1.1}"
  local default_server_countries="${SERVER_COUNTRIES:-Sweden}"
  local default_homepage_allowed_hosts="${HOMEPAGE_ALLOWED_HOSTS:-*}"
  local default_allowed_ips="${WIREGUARD_ALLOWED_IPS:-0.0.0.0/0,::/0}"

  printf "%b\n" "${C_BOLD}Environment Setup${C_RESET}"

  COMMON_PATH="$(prompt_default "COMMON_PATH" "${default_common_path}")"
  TZ="$(prompt_default "TZ" "${default_tz_value}")"
  PUID="$(prompt_default "PUID" "${default_puid}")"
  PGID="$(prompt_default "PGID" "${default_pgid}")"
  NGINX_PORT="$(prompt_default "NGINX_PORT" "${default_nginx_port}")"
  JELLYSEERR_PORT="$(prompt_default "JELLYSEERR_PORT" "${default_jellyseerr_port}")"
  DNS="$(prompt_default "DNS" "${default_dns}")"
  SERVER_COUNTRIES="$(prompt_default "SERVER_COUNTRIES" "${default_server_countries}")"
  HOMEPAGE_ALLOWED_HOSTS="$(prompt_default "HOMEPAGE_ALLOWED_HOSTS" "${default_homepage_allowed_hosts}")"

  printf "\n"
  printf "%b\n" "${C_BOLD}Required API Keys and Secrets${C_RESET}"

  UNPACKERR_SONARR_API_KEY="$(prompt_required "UNPACKERR_SONARR_API_KEY" "${UNPACKERR_SONARR_API_KEY:-}")"
  UNPACKERR_RADARR_API_KEY="$(prompt_required "UNPACKERR_RADARR_API_KEY" "${UNPACKERR_RADARR_API_KEY:-}")"

  printf "\n"
  printf "%b\n" "${C_BOLD}Required WireGuard Settings${C_RESET}"

  WIREGUARD_ADDRESSES="$(prompt_required "WIREGUARD_ADDRESSES" "${WIREGUARD_ADDRESSES:-}")"
  WIREGUARD_PRIVATE_KEY="$(prompt_required "WIREGUARD_PRIVATE_KEY" "${WIREGUARD_PRIVATE_KEY:-}")"
  WIREGUARD_PUBLIC_KEY="$(prompt_required "WIREGUARD_PUBLIC_KEY" "${WIREGUARD_PUBLIC_KEY:-}")"
  WIREGUARD_ENDPOINT="$(prompt_required "WIREGUARD_ENDPOINT" "${WIREGUARD_ENDPOINT:-}")"
  WIREGUARD_ALLOWED_IPS="$(prompt_default "WIREGUARD_ALLOWED_IPS" "${default_allowed_ips}")"
}

confirm_continue() {
  local answer
  read -r -p "Continue with these settings? [Y/n]: " answer
  if [[ -n "${answer}" && ! "${answer}" =~ ^[Yy]$ ]]; then
    die "Setup cancelled by user."
  fi
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --non-interactive)
      NON_INTERACTIVE=1
      shift
      ;;
    --env-file)
      [[ $# -ge 2 ]] || die "--env-file requires a path"
      ENV_FILE="$2"
      shift 2
      ;;
    --force)
      FORCE=1
      shift
      ;;
    --no-color)
      NO_COLOR=1
      C_RESET=''
      C_BOLD=''
      C_DIM=''
      C_RED=''
      C_GREEN=''
      C_YELLOW=''
      C_BLUE=''
      C_CYAN=''
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      die "Unknown argument: $1"
      ;;
  esac
done

if [[ "${ENV_FILE}" != /* ]]; then
  ENV_FILE="${REPO_ROOT}/${ENV_FILE}"
fi

[[ -f "${EXAMPLE_FILE}" ]] || die "Missing ${EXAMPLE_FILE}"

print_header
log_info "Environment file: ${ENV_FILE}"
if [[ "${NON_INTERACTIVE}" -eq 1 ]]; then
  log_info "Mode: non-interactive"
else
  log_info "Mode: interactive"
fi

log_step "Prerequisite checks"
require_commands
log_ok "Docker and Docker Compose checks passed."

log_step "Environment configuration"
if [[ "${NON_INTERACTIVE}" -eq 1 ]]; then
  load_env_file
  validate_required_env
  log_ok "Loaded and validated ${ENV_FILE}."
else
  if [[ -f "${ENV_FILE}" ]]; then
    set -a
    # shellcheck disable=SC1090
    source "${ENV_FILE}"
    set +a

    if [[ "${FORCE}" -eq 0 ]]; then
      read -r -p "${ENV_FILE} exists. Reuse and validate current values? [Y/n]: " reuse
      if [[ -z "${reuse}" || "${reuse}" =~ ^[Yy]$ ]]; then
        validate_required_env
        log_ok "Using existing env file values."
      else
        interactive_collect
        print_summary
        confirm_continue
        write_env_file
      fi
    else
      interactive_collect
      print_summary
      confirm_continue
      write_env_file
    fi
  else
    interactive_collect
    print_summary
    confirm_continue
    write_env_file
  fi
fi

validate_required_env
log_ok "Required env values are present."

log_step "Folder provisioning"
create_directories

log_step "Compose preflight"
run_preflight

log_step "Final summary"
print_final_summary

printf "\n"
log_ok "Setup completed successfully."
printf "%b\n" "${C_BOLD}Next:${C_RESET} docker compose --env-file ${ENV_FILE} up -d"
